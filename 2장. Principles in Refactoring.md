# 2장. Principles in Refactoring

**Defining Refactoring**

- A change made to the internal structure of software to make it easier to understand and cheaper to modify without chaning its observable behavior.
- To restructure software by applying a series of refactorings without changing its observable behavior.

- 리팩토링은 프로그램의 전체 기능을 변화하지 않는 내에서 코드를 조작한다는 점에서 성능최적화와 유사하다. 차이는 목적에 있다. 리팩토링은 코드를 이해하기 쉽고 변화에 용이하게 하기 위해 한다. 이것은 프로그램의 속도를 빠르게 할수도, 느리게 할수도 있다.  성능 최적화는 오직 속도를 향상하고 퍼포먼스를 개선할 필요가 있을때에 코드를 작업하게 된다.

### 두개의 모자

- 나는 개발을 할 때 내 시간을 두개의 분명한 활동으로 구분한다: 기능을 추가하는 것 / 리팩토링
    - 기능을 추가할 때에는 단지 새로운 기능을 넣을 뿐이다. 나의 진척정도를 테스트를 추가하고 테스트가 돌아가게 함으로써 측정한다.
    - 반면 리팩터링을 할때는 오직 코드의 구조를 변화하는데에만 촛점을 맞춘다. 테스트를 추가하지도 않는다. 단지 인터페이스의 변화가 있을때 테스트 코드를 수정할 뿐이다.
- 소프트웨어를 개발하면서 이 두개의 모자를 빠르게 교체하면서 일을 한다. 그러면서 항상 내가 어떤 모자를 쓰고 있는지 인지를 하는데, 이 미묘한 차이가 내가 프로그래밍을 어떻게 하는지에 영향을 미친다.

### 왜 리팩터링을 해야하는가?

- 리팩터링은 소프트웨어의 디자인을 개선한다.
    - 코드의 디자인을 보기 어려울 수록, 그 코드를 보전하기도 어렵고 더 빠르게 부패한다. 정기적인 리팩터링은 코드의 형태를 보전해준다.
    - 안 좋게 디자인된 코드는 같은 동작을 하게 하기 위해 더 많은 코드를 필요로 하는데, 이는 종종 그 코드가 여러번 되풀이되고 있기 때문이다. 그러므로 디자인을 개선하는 중요한 요소 하나는 중복된 코드를 제거하는 것이다. 코드가 많을 수록 제대로 수정하기 어려워진다. 이해할 코드가 더 많아지기 때문이다.
- 리팩터링은 소프트웨어를 더 이해하기 쉽게 해준다.
    - Programming is all about saying exactly what I want.
- 리팩터링은 버그를 찾기 쉽게 해준다.
    - 프로그램의 구조를 명확하게 함으로써, 나는 내가 만든 특정한 가정을 밝혀낸다. 이 과정에서 버그를 발견하는걸 피할 수 없다.
    - Kent Beck은 종종 자기 자신에 대해 이렇게 말한다.
        
        "I'm not a great programmer. I'm just good programmer with great habits." 
        
- 리팩터링은 프로그램을 더 빨리 개발할 수 있게 해준다.
    - 앞선 이점들은 다음의 결론에 이른다 : 리팩터링은 코드를 더욱 빠르게 칠 수 있게 해준다.
    이건 역설적으로 들린다. 대부분의 사람들은 리팩터링의 이점이 품질의 향상이라는 것을 쉽게 발견한다. 하지만 리팩터링에 들인 시간이 개발의 시간을 줄여주진 않을까?
    - 대부분의 개발자들이 초반에는 급격히 빠른 진전을 만들 수 있었지만 지금은 새로운 기능을 추가하는데에 훨씬 시간이 오래걸린다고 이야기한다. 매번 새로운 기능을 추가해야할 때마다 현재 존재하고 있는 코드에 어떻게 들어맞게 할지 이해하는데 시간을 필요로 한다. 이 때문에 개발자들은 처음부터 새로 시작하고싶다고 말하게 된다.
    - 좋은 디자인을 가진 소프트웨어는 새로운 기능을 추가하기 위해 어떤 변화를 어디에 줘야할지 찾기 쉽게 해준다. 코드가 깨끗하면 버그를 설명할 가능성이 줄어들고 그렇다면 디버깅을 하는 수고로움은 훨씬 더 쉬워진다.
    

### 언제 리팩터링을 해야할까?

- Preparatory Refactoring - 새로운 기능을 추가하기 더 쉽게 해주는 것
    - 리팩터링을 하기 가장 좋은 시간은 새로운 기능을 코드베이스에 추가할 필요가 있기 바로 전이다. 아마 이미 존재하는 코드 중에 유사한 일을 하고 있는 코드가 있을 수도 있다. 그 코드를 복사하여 약간만 변형하여 추가할 수도 있겠지만 `Parameterize Function` 을 사용하여 리팩터링 할 수 있다. 함수에 변형이 필요한 부분만 파라미터화 하는 것이다.
- Comprehensive Refactoring - 코드를 이해하기 쉽게 만들어주는 것
    - 어떤 코드가 무슨 일을 하고 있는지 이해해야할때마다, 나는 그 코드를 더욱 즉각적으로 명확한 이해를 할 수 있게 리팩터링을 한다면 어떻게 해야할지 스스로에게 질문한다.
    - 리팩터링을 통해 내 이해를 머릿속에서 코드 그 자체로 옮긴다. 그 후 소프트웨어가 잘 작동하는 것을 확인하는 테스트를 거친 뒤에 동료들에게 보여지고 더 오래 지속될 수 있게 된다.
- Litter-pickup Refactoring
    - 더러운 코드, 문제있는 코드를 발견했을 때 즉시 해결하는 것.
- Planned and Opportunistic Refactoring
- Long term refactoring

### 언제 리팩터링을 하지 말아야할까?

- 수정할 필요가 없는 거대한 코드에 맞닥뜨렸을때는 리팩터링을 할 필요가 없다.
- 새로 쓰는게 리팩터링을 하는 것보다 빠르다면 리팩터링을 할 필요가 없다.

### 리팩터링, 아키텍쳐, 그리고 Yagni (You aren't gonna need it)

- 소프트웨어 업계에서는 오래 전부터 소프트웨어 디자인과 아키텍쳐가 코드를 작성하기 전에 완수되어야 하는 어떤 것이라고 여겨져왔다.
- 하지만 리팩터링은 이 관점을 바꿔버린다. 코드를 작성하기 전에 아키텍쳐를 작업을 끝내버리는 것과 같은 접근은 해당 소프트웨어가 아주 일찍이 이해되었다는 것을 가정한다. 하지만 이건 보통 이룰 수 없는 목표와도 같다.
- 미래의 발생할 수 있는 변화를 다루는 하나의 방법은 소프트웨어에 유동성의 메커니즘을 집어넣는 것이다. 하지만 리팩터링을 이용하면 다른 전략을 사용할 수 있다. 미래에 내가 어떤 유동성이 필요할지 추측하는 대신, 지금의 이해된 니즈만을 푸는 훌륭하게 디자인된 소프트웨어를 개발하는 것이다. 유저에 대한 내 이해가 변화함에 따라, 새로운 요구사항에 대한 아키텍쳐를 수용하는 리팩터링을 하면 된다.
